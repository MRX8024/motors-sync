## Добро пожаловать в проект синхронизации шаговых двигателей для AWD систем

### Поддерживаемые кинематики:
`CoreXY` / `Cartesian` `4 WD`

### Как это работает?
В системах AWD один ремень приводится в движение двумя двигателями и
разделяется шкивами на два контура. Двигатели при активации некорректно
восстанавливают свою предыдущую позицию: ремень на одном контуре
растягивается, а на другом ослабевает. Синхронизация заключается в
выравнивании натяжения этих двух контуров. При отключении одного из
двигателей, натяжение контуров выравнивается и его ротор проворачивается.
При повторной активации этот ротор возвращается в предыдущую позицию с
характерным ударом. Сила этого удара зависит от разницы в натяжении между
контурами. Чем больше разница, тем сильнее удар; если разница минимальна,
удара не происходит. Магнитуду ударов измеряет акселерометр, постоянно
закрепленный на каретке, либо энкодер, прикрепленный к мотору. Синхронизация
софтовая, а значит сбрасывается при отключении любого из шаговых двигателей
на контуре ремня. Скрипт определяет направление вращения ротора, постепенно
подстраивает его положение, пока магнитуда удара уменьшается. Если она
начинает расти, то происходит откат к предыдущей позиции и синхронизация
завершается, либо совершает дополнительные итерации, для достижения
заданного порога магнитуды n-ное кол-во раз.

### Примечания:
* Рекомендуется жестко фиксировать акселерометр в ближайшей точке к
  креплению ремней каретки. Крепление в других местах, например
  использование акселерометра CAN-платы или Beacon-а на пластичном 
  креплении, может привести к искажению измерений.

* Не рекомендуется использовать акселерометр `lis2dw` ввиду малой
  частоты дискретизации, он может плохо определять пики колебаний,
  однако его работа оптимизирована отключением фильтрации данных.

* Не включайте нагрев хотенда во время синхронизации. Работающий
  вентилятор (в целом любой вентилятор в принтере) может помешать
  корректному и более точному измерению. Измерить/cравнить шумы вы
  можете стандартной командой клиппера - [MEASURE_AXES_NOISE
  ](https://www.klipper3d.org/G-Codes.html#measure_axes_noise)

* В большинстве случаев не стоит повышать значение параметра синхронизации 
  `microsteps` выше 16 при 20т шкиве, разница между магнитудой соседних
  положений ротора будет мизерна, что может дать ложную калибровку.

### Установка скрипта калибровки на хост принтера
```
cd ~
git clone https://github.com/MRX8024/motors-sync
bash ~/motors-sync/install.sh
```

###  Конфигурация
Большинство параметров поддерживают само-указание под ось, например при
`axes: x,y` параметр `accel_chip` может быть описан как `accel_chip_x` и
`accel_chip_y`. Но `accel_chip` останется параметром по умолчанию, если
нет указания для конкретной оси. Это актуально для кинематики `сartesian`,
которая может иметь разные реализации приводных узлов.

Параметры, начинающиеся с символа `#`, являются необязательными для
настройки. Они имеют базовые значения по умолчанию, которые указаны рядом
с ними, но могут быть модифицированы под разные конфигурации принтеров.
Рекомендуется ознакомиться со всеми возможными параметрами конфигурации,
перед началом пользования программы.

Добавляем в конфигурационный файл принтера раздел, и частично настраиваем
его для первого замера -

```
[motors_sync]
axes: x,y
#    Оси на которых будет производиться калибровка.
accel_chip:
#    Aкселерометр для сбора вибраций: adxl345 / mpu9250 и т.п.
#encoder_chip_<axis>:
#    Ось, присвоенное имя энкодеру, для замера отклонений.
#chip_filter: median
#    Тип фильтра данных акселерометра: 'median' обычно хватает, но особо
#    шумные принтеры (вентиляторов, и т.п.) могут потребовать более мощный
#    фильтр - 'kalman'. Для lis2dw фильтры отключены.
#median_size: 3
#    Размер окна медианного фильтра.
#kalman_coeffs: 1.1, 1., 1e-1, 1e-2, .5, 1.
#    Простые коэффициенты, описывающие фильтр Калмана.
#microsteps: 16
#    Максимальное дробление смещения ротора шагового двигателя.
#steps_model: linear, 20000, 0
#    Математическая модель и ее коэфициенты зависимости смещения
#    микрошагов шагового двигателя от величины измеренных колебаний.
#max_step_size: 3
#    Максимальное количество микрошагов на которые мотор может
#    передвинуться за раз, для достижения планируемой магнитуды.
#axes_steps_diff: 4
#    Разница позиций моторов в микрошагах между двумя осями, для запуска
#    проверки смещения магнитуды вторичной оси на кинематиках аля corexy.
#    Значение по умолчанию - max_step_size + 1.
#retry_tolerance: 0
#    Принудительный порог, до которого пара шаговых двигателей на одном
#    ремне, должна будет опустить величину колебаний. Рекомендуется к
#    настройке, дабы фильтровать возможные ошибки измерений. После
#    нескольких итераций запуска синхронизации вы найдете порог, до
#    которого можно опустить значение этого параметра.
#retries: 0
#    Максимальное количество повторений для достижения принудительного
#    порога колебаний.
#head_fan:
#    Вентилятор хотенда, который будет выключаться на время синхронизации
#    для исключения его шумов.
```

### Синхронизация моторов
Вводим команду `SYNC_MOTORS` в терминале, на главной странице веб
интерфейса, и ждем завершения процесса. Некоторые параметры можно
переопределять:
```
SYNC_MOTORS AXES=[<axes>] ACCEL_CHIP=[<chip_name>] [RETRY_TOLERANCE=<value>] [RETRIES=<value>]
```
Так же их можно указать под конкретную ось, например `ACCEL_CHIP_X`, в
ином случае будет переопределение параметра для выбранных или всех осей.

### Автоматизация
Синхронизация обычно запускается в начале печати, во время прогрева
принтера. Для этого нужно добавить ее в макрос \ слайсер. Например -
```
...
M140 S   ; set bed temp
SYNC_MOTORS
G28 Z
M190 S   ; wait for bed temp to stabilize
M104 S   ; set extruder temp
...
```

### Переменная статуса калибровки 
Вводится переменная статуса калибровки, которая сбрасывается при выключении
моторов принтера. Вы можете проверять её состояние внутри макроса. В случае
положительного статуса не делать лишний раз калибровку, если она была уже
выполнена в текущем сеансе. Для примера -
```
...
G28 X Y
{% if not printer.motors_sync.applied %}
    SYNC_MOTORS
{% endif %}
G28 Z
...
```

### Калибровка модели синхронизации
Модель из себя представляет зависимость микрошагов к магнитуде. По
умолчанию она линейная с коэффициентом 20к, это означает что на 20к
магнитуды приходится по 1 микрошагу смещения. Это базовое безопасное
значение, и у каждого пользователя в зависимости от его конфигурации
принтера, и даже акселерометра, эта зависимость будет иной. Калибровка
модели призвана найти подходящую функцию и её коэффициенты, описывающие
зависимость микрошагов от магнитуды, конкретно для вашего принтера.

```
SYNC_MOTORS_CALIBRATE AXIS=<axis> [DISTANCE=<value>] [REPEATS=<value>] [PLOT=<0/1>]
```

`AXIS=` это желаемая вами ось для калибровки. В случае `corexy` выбираем
любую из `x`,`y`; калибровка на обе оси будет единой. По умолчанию
совершается 2 итерации повышения позиции ротора до +16/16 шага и затем
уменьшение до -16/16 с шагом в 1/16, во время которых измеряются удары и
записываются контрольные точки. Калибровка происходит с шагом 1/16 для
стабильности результата. Модель автоматически подстроится под ваше значение
микрошагов в конфигурации, если оно не равно 16. `DISTANCE` задает
относительное смещение микрошагов, относительно 16ти. `REPEATS` определяет
количество повторений. `PLOT` - создавать ли график, по умолчанию создается.

После завершения калибровки вы увидите в терминале предложение сохранить
модель в конфиг, а так же путь до графического изображения. Открыв файл
можно увидеть следующее -

<img src="/wiki/pictures/model_calibrate.png" width="600">

На графике в таблице указаны названия моделей, коэффициенты, и RMSE
(среднеквадратичное отклонение) от измеренных точек, отсортированные в
порядке возрастания. Если вы не уверены, что алгоритм отработал корректно
в вашем случае, например линии функций плохо повторяют ваши данные
(точки) - откройте issue и приложите график с другими данными.

Для кинематики `corexy` модель сохраняется сразу под обе оси. Для других
кинематик выберите один из методов:
* Откалибруйте модель под каждую ось, если это имеет смысл;
* Вручную укажите откалиброванную модель под желаемые оси:
  ```
  steps_model_a: ...
  steps_model_b: ...
  steps_model_c: ...
  ```
* Вручную укажите общую модель под все оси:
  ```
  steps_model: ...
  ```
Стоит напомнить, что значение для конкретной оси более значимо, чем для
всех осей, и будет переопределять его.

### Статистика калибровок
Каждая итерация синхронизации записывается в журнал, который располагается
в директории со скриптом. Это позволяет при первом запуске синхронизации
после включения принтера восстановить положения моторов на основе предыдущей
успешной синхронизации, а также получить статистику синхронизаций с помощью
следующей команды:
```
SYNC_MOTORS_STATS
```
Для очистки можно использовать команду:
```
SYNC_MOTORS_STATS CLEAR=true
```

### Синхронизация по энкодерам
Энкодеры обладают повышенной точностью вплоть до 1/128 шага, не зависят
от расположения принтера в пространстве и быстрее выполняют процесс
синхронизации. Поддерживаются любые энкодеры, описанные в [клиппер вики
](https://www.klipper3d.org/Config_Reference.html#angle), установить его
можно на любой из моторов в контуре ремня. После установки рекомендуется
выполнить возможные внутренние калибровки сенсора, и затем калибровку в
клиппере. По умолчанию количество микрошагов в шаге считается по длине
отклонения вала ротора, однако можно откалибровать модель синхронизации
так же, как и с акселерометром. Значение параметра `max_step_size` можно
завысить, так как это работает стабильнее, нежели с акселерометром, и
может сильно ускорить процесс синхронизации. Однако на некоторых принтерах
повышенное значение все еще может вызывать непредсказуемый результат.

### Контакты
Используйте систему issue на GitHub.
Вы также можете написать мне лично в Discord — @mrx8024.

### Немного истории:
Идея проекта родилась летом 2023 года. Тогда ее первый автор @altzbox
понял, что с помощью акселерометра можно измерить силу удара при активации
моторов. Комьюнити эту идею приняло без энтузиазма, а реализовать проект
самостоятельно ему мешал недостаточный уровень навыков в программировании.
Через полгода, устав от ручной синхронизации моторов, @altzbox решил
написать код с помощью ChatGPT, и в Январе 2024 года появилась первая
рабочая [версия](https://github.com/altzbox/motors_sync), но для
дальнейшего развития проекта навыков уже не хватало. Весной 2024 года,
я (@mrx8024) заинтересовался этой идеей и решил продолжить разработку.
